/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package photo.backup.kt

import arrow.core.*
import arrow.core.extensions.fx
import arrow.fx.IO
import arrow.fx.extensions.fx
import arrow.fx.extensions.io.applicative.applicative
import arrow.fx.fix
import ch.frankel.slf4k.debug
import ch.frankel.slf4k.error
import ch.frankel.slf4k.info
import ch.frankel.slf4k.trace
import ch.qos.logback.classic.LoggerContext
import ch.qos.logback.core.util.StatusPrinter
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import photo.backup.kt.data.*
import photo.backup.kt.data.source.IBackupRepository
import photo.backup.kt.data.source.BackupRepository
import photo.backup.kt.data.source.RepoType
import photo.backup.kt.domain.*
import photo.backup.kt.photo.backup.kt.domain.RenewFileUseCase
import java.io.File
import java.nio.file.Files
import java.nio.file.Files.createDirectories
import java.nio.file.Path
import java.security.MessageDigest
import java.util.*
import javax.imageio.ImageIO
import javax.xml.bind.DatatypeConverter
import kotlin.system.measureTimeMillis

inline class SessionId(val value: UUID)

//private val logger: Logger = LoggerFactory.getLogger("test")

private val logger = LoggerFactory.getLogger("test")

class App(private val params: Params) {

    data class Params(val sourceRootPath: String,
                      val backupRootPath: String,
                      val getFilesUseCase: ScanDirectoryUseCase,
                      val hashUseCase: ComputeHashUseCase,
                      val getMediaTypeUseCase: DetermineMediaTypeUseCase,
                      val insertUseCase: SavePhotoUseCase,
                      val getDataUseCase: GetDataUseCase,
                      val getDupeListUseCase: ListDupesUseCase,
                      val moveDupesUseCase: MoveFileUseCase,
                      val storeUnknownFileRefUseCase: StoreUnknownFileRefUseCase,
                      val sessionId: SessionId,
                      val needToUpdateHashUseCase: NeedToUpdateHashUseCase,
                      val renewFileUseCase: RenewFileUseCase
    )

    private fun scanPath(path: String, stage: StageType): IO<Sequence<Option<MediaId>>> = with(params){IO.fx {
        val (filesSeq: Sequence<File>) = getFilesUseCase(path)
        val programs: Sequence<IO<Option<MediaId>>> = filesSeq.map { file ->
            val mediaTypeEither = getMediaTypeUseCase(file)
            mediaTypeEither.fold({
                storeUnknownFileRefUseCase(file).map { None }
            },{ mediaType ->
                IO.fx {
                    val update: Boolean = needToUpdateHashUseCase(file, stage).bind()
                    if(update) {
                        val (data: Either<Throwable, ByteArray>) = getDataUseCase(GetDataUseCase.Params(file, mediaType))
                        data.fold({
                            logger.error { "Could not read in the file ${file.canonicalPath}: $it" }
                            None
                        },{
                            val (hashId: HashId) = hashUseCase(it, file.canonicalPath, file.lastModified(), stage)
                            val myFile = EntityFactory.build(stage, file, Some(hashId), mediaType).copy(sessionId)
                            Some(insertUseCase(myFile).bind())
                        })
                    } else {
                        logger.trace { "Skipping re-hashing of ${file.name}"}
                        renewFileUseCase(file, stage)
                        None
                    }
                }
            })
        }
        programs.map { it.unsafeRunSync() }
    } }

    private fun doMoves(): IO<List<Either<Throwable, Path>>> =
        params.getDupeListUseCase().flatMap { list ->
            logger.info("Going to move ${list.size} dupes")
            list.k().traverse(IO.applicative()) { file ->
                params.moveDupesUseCase(file)
            }.fix()
        }

    fun execute(): IO<Unit> = IO.fx {
        with(params) {
            logger.info("Scanning source path")
            scanPath(sourceRootPath, source).bind() + scanPath(backupRootPath, backup).bind().count()
            logger.info("Scanning backup path")
            videoMain(arrayOf(sourceRootPath, backupRootPath), sessionId, repository).bind().count()
            logger.info("Doing moves")
            doMoves().bind()
            Unit
        }
    }
}

class ScanPathUseCase(private val params: App.Params) {
    operator fun invoke(path: File, stage: StageType): IO<Sequence<Option<MediaId>>> = with(params){
        IO.fx {
            val (filesSeq: Sequence<File>) = getFilesUseCase(path.canonicalPath)
            val programs: Sequence<IO<Option<MediaId>>> = filesSeq.map { file ->
                logger.debug { "Processing ${file.canonicalPath}"}
                logger.trace { "Media type?" }
                val mediaTypeEither = getMediaTypeUseCase(file)
                mediaTypeEither.fold({
                    logger.trace { "It was unknown type"}
                    storeUnknownFileRefUseCase(file).map { None }
                },{ mediaType ->
                    IO.fx {
                        val (data: Either<Throwable, ByteArray>) = getDataUseCase(GetDataUseCase.Params(file, mediaType))
                        data.fold({
                            None
                        },{
                            val (hashId: HashId) = hashUseCase(it, file.canonicalPath, file.lastModified(), stage)
                            val myFile = EntityFactory.build(stage, file, Some(hashId), mediaType).copy(sessionId)
                            Some(insertUseCase(myFile).bind())
                        })
                    }
                })
            }
            programs.map { it.unsafeRunSync() }
        } }
}

val IMAGE_EXTENSIONS = listOf("jpg", "gif", "jpeg", "cr2", "raw", "png")
val VIDEO_EXTENSIONS = listOf("avi", "mpg", "mpeg", "mp4", "mov", "3gp")
val FORBIDDEN_PATHS = listOf(".@__thumb", ".aplibrary", ".git", "node_modules")


private var walker: (String) -> Sequence<File> = {
    File(it).walk().onEnter { dir ->
        logger.debug { "Scanning for files in $dir" }
        FORBIDDEN_PATHS.all { !dir.canonicalPath.endsWith(it) }
    }.filter { it.isFile && it.extension.toLowerCase() `in` IMAGE_EXTENSIONS }
}
private var hasher: suspend (ByteArray) -> Hash = { data ->
    val md5 = MessageDigest.getInstance("MD5")
    md5.update(data)
    val digest = md5.digest()
    Hash(DatatypeConverter.printHexBinary(digest).toUpperCase())
}

sealed class BackupExceptions {
    object NoSourceRoot: BackupExceptions()
    object NoBackupRoot: BackupExceptions()
    object NoDestinationRoot: BackupExceptions()
    object Crawling: BackupExceptions()
}

fun main(args: Array<String>) {

    val lc = LoggerFactory.getILoggerFactory() as LoggerContext
    StatusPrinter.print(lc)

    val sessionId = SessionId(UUID.randomUUID())

//    argsParser(args).fold({
//        println("Could not run program because $it")
//    },{
//        val (sourceRoot, backupRoot, destinationRoot) = it
//        val params = App.Params(
//                "",
//                "",
//                ScanDirectoryUseCase(walker),
//                ComputeHashUseCase(repository, hasher, sessionId),
//                DetermineMediaTypeUseCase(),
//                SavePhotoUseCase(repository, sessionId),
//                GetDataUseCase({x->imageReader(x)}, videoReader),
//                ListDupesUseCase(repository, sessionId),
//                MoveFileUseCase(destinationRoot, mover),
//                StoreUnknownFileRefUseCase(repository, sessionId),
//                sessionId
//        )
//        val scan = ScanPathUseCase(params)
//        sourceRoot.map { scan(it, source) }
//        backupRoot.map { scan(it, backup) }
//    })

    val sourceRootIO: IO<Either<BackupExceptions, String>> = IO { args[0] }.attempt()
            .map { it.mapLeft { BackupExceptions.NoSourceRoot } }
    val backupRootIO: IO<Either<BackupExceptions, String>> = IO { args[1] }.attempt()
            .map { it.mapLeft { BackupExceptions.NoBackupRoot}}
    val destinationRootIO: IO<Either<BackupExceptions, String>> = IO { args[2] }.attempt().map { it.mapLeft { BackupExceptions.NoDestinationRoot }}

//    sourceRootIO.map {
//        it.map {sourcePathStr ->
//            backupRootIO.map {
//                it.map{backupPathStr ->
//                    destinationRootIO.map {
//                        it.map { destinationPathStr ->
//
//                        }
//                    }
//                }
//            }
//        }
//    }

    val app: IO<Unit> = IO.fx {
        val sourceRoot = sourceRootIO.bind()
        logger.trace{ "Source is $sourceRoot"}
        val backupRoot = backupRootIO.bind()
        logger.trace { "Backup is $backupRoot"}
        val destinationRoot: String = destinationRootIO.bind().fold({ File("").canonicalPath }, { File(it).canonicalPath })
        logger.trace { "Destination is $destinationRoot" }
        if(sourceRoot is Either.Right && backupRoot is Either.Right) {
            logger.trace { "Building application" }
            val app = App(App.Params(
                    sourceRoot.b,
                    backupRoot.b,
                    ScanDirectoryUseCase(walker),
                    ComputeHashUseCase(repository, hasher, sessionId),
                    DetermineMediaTypeUseCase(),
                    SavePhotoUseCase(repository, sessionId),
                    GetDataUseCase({x->imageReader(x)}, videoReader),
                    ListDupesUseCase(repository, sessionId),
                    MoveFileUseCase(destinationRoot, mover),
                    StoreUnknownFileRefUseCase(repository, sessionId),
                    sessionId,
                    NeedToUpdateHashUseCase(repository),
                    RenewFileUseCase(repository, sessionId)
            ))
            logger.info { "Application built"}
            app.execute().bind()
        }
    }
    measureTimeMillis {
        app.unsafeRunSync()
    }.run { println("Execution took ${this/1000} seconds") }

}


/**
 * Currently have no better way to hash a video's data except to hash the whole file
 */
val videoReader: suspend (File)->ByteArray = {
    println("Read video ${it.canonicalPath}")
    it.readBytes()
}

val mover: suspend (destStr: String, toMove: File)->Either<Throwable, Path> = { destStr, it ->
    Either.fx {
        val dest: Path = customResolve(destStr, it)
        val parentPath = dest.parent
        createDirectories(parentPath)
        Files.move(it.toPath(), dest)
        dest
    }
}

private val repository: IBackupRepository = BackupRepository.newInstance(RepoType.PROD)

private fun customResolve(base: String, toCopy: File): Path {
    return File(base).toPath().resolve(".${toCopy.canonicalPath}")
}

/**
 * This should fetch purely the image data and nothing else
 */

fun imageReader(file: File): IO<Either<Throwable, ByteArray>> = IO.fx {
    with(!effect { ImageIO.read(file) }) {
        val argbArray = getRGB(0,0, width, height,null,0, width)
        val buffer = java.nio.ByteBuffer.allocate(4*argbArray.size)
        argbArray.forEach { buffer.putInt(it) }
        buffer.flip()
        buffer.array().slice(0 until argbArray.size*4).toByteArray()
    }
}.attempt()

//private val imageReader: suspend (File)->ByteArray = {
//    with(ImageIO.read(it)) {
//        val argbArray = getRGB(0,0, width, height,null,0, width)
//        val buffer = ByteBuffer.allocate(4*argbArray.size)
//        argbArray.forEach { buffer.putInt(it) }
//        buffer.flip()
//        buffer.array().slice(0 until argbArray.size*4).toByteArray()
//    }
//}

data class PathArgs(val source: Option<File>, val backup: Option<File>, val destination: Option<File>)

fun argsParser(args: Array<String>): Either<ArgumentsException, PathArgs> {
    return when(args.size) {
        0 -> return Left(ArgumentsException.NoPaths)
        1 -> return Right(PathArgs(Some(File(args[0])), None, None))
        2 -> return Right(PathArgs(Some(File(args[0])), Some(File(args[1])), Some(File(""))))
        3 -> return Right(PathArgs(Some(File(args[0])), Some(File(args[1])), Some(File(args[2]))))
        else -> Left(ArgumentsException.TooManyPaths)
    }
}

sealed class ArgumentsException {
    object NoPaths: ArgumentsException()
    object TooManyPaths: ArgumentsException()
}