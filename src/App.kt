/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package photo.backup.kt

import arrow.core.*
import org.slf4j.LoggerFactory
import photo.backup.kt.data.source.IBackupRepository
import photo.backup.kt.data.source.BackupRepository
import photo.backup.kt.data.source.RepoType
import photo.backup.kt.domain.*
import photo.backup.kt.util.*
import java.io.File
import java.util.*

inline class SessionId(val value: UUID)

private val logger = LoggerFactory.getLogger("test")

val IMAGE_EXTENSIONS = listOf("jpg", "gif", "jpeg", "raw", "png", "tiff")
val VIDEO_EXTENSIONS = listOf("avi", "mpg", "mpeg", "mp4", "mov", "3gp", "cr2")
val FORBIDDEN_PATHS = listOf(".@__thumb", ".aplibrary", ".git", "node_modules")


fun main(args: Array<String>, testing: Boolean = false) {
    val sessionId = SessionId(UUID.randomUUID())

    val repository = when(testing) {
        true -> BackupRepository.newInstance(RepoType.TEST)
        false -> BackupRepository.newInstance(RepoType.PROD)
    }

    val runner = createRunner(
        sessionId,
        { scanVideo(it, videoWalker) },
        generateStoreVideoUseCase(repository, sessionId, ::generateMD5),
        generateShouldStoreBackupVideoUseCase(repository, sessionId, ::generateMD5)
    )

    argsParser(args).map {
        main(it, UseCases(
            generateBatchUpdateSession(repository, sessionId),
            generateListDupesUseCase(repository, sessionId),
            generateMoveFileUseCase(::mover),
            runner,
            generateScanDirectoryUseCase { imageWalker(File(it)) },
            generateStoreUnknownFileRefUseCase(repository, sessionId),
            generateNeedToUpdateHashUseCase(repository),
            generateGetImageDataUseCase(::imageReader),
            generateComputeHashUseCase(repository, calculateHash, sessionId),
            generateSavePhotoUseCase(repository, sessionId)))
    }
}

data class PathArgs(val source: Option<File>, val backup: Option<File>, val destination: Option<File>)

fun argsParser(args: Array<String>): Either<ArgumentsException, PathArgs> {
    return when(args.size) {
        0 -> return Left(ArgumentsException.NoPaths)
        1 -> return Right(PathArgs(Some(File(args[0])), None, None))
        2 -> return Right(PathArgs(Some(File(args[0])), Some(File(args[1])), Some(File(""))))
        3 -> return Right(PathArgs(Some(File(args[0])), Some(File(args[1])), Some(File(args[2]))))
        else -> Left(ArgumentsException.TooManyPaths)
    }
}

sealed class ArgumentsException {
    object NoPaths: ArgumentsException()
    object TooManyPaths: ArgumentsException()
}