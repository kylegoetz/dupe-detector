/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package photo.backup.kt

import arrow.core.Either
import arrow.core.None
import arrow.core.Some
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.File

class AppTest {
    @Test
    @DisplayName("argsParser gives NoPaths exception when no args")
    fun argsParserHandlesZeroArgs() {
        val result = argsParser(emptyArray())
        assertEquals(Either.left(ArgumentsException.NoPaths), result)
    }

    @Test
    @DisplayName("argsParser gives TooManyPaths exception when 4 or more args")
    fun tooManyPaths() {
        val result = argsParser(arrayOf("", "", "", ""))
        assertEquals(Either.left(ArgumentsException.TooManyPaths), result)
    }

    @Test
    @DisplayName("argsParser gives Some Some Some('') for 2 args")
    fun twoArgs() {
        val result = argsParser(arrayOf("foo", "bar"))
        assertEquals(Either.right(PathArgs(Some(File("foo")), Some(File("bar")), Some(File("")))), result)
    }

    @Test
    @DisplayName("argsParser gives Some none None for 1 arg")
    fun oneArg() {
        val result = argsParser(arrayOf("foo"))
        assertEquals(Either.right(PathArgs(
            Some(File("foo")),
            None,
            None)), result)
    }

    @Test
    @DisplayName("argsParser gives Some Some Some for 3 args")
    fun threeArgs() {
        val result = argsParser(arrayOf("foo", "bar", "baz"))
        assertEquals(Either.right(PathArgs(
            Some(File("foo")),
            Some(File("bar")),
            Some(File("baz"))
        )), result)
    }
}
//
//private const val SOURCE_PATH = "/path/to/source"
//private const val BACKUP_PATH = "/path/to/backup"
//
//val logger = LoggerFactory.getLogger("test")
//
//class AppTest {
//    @MockK private lateinit var repo: IBackupRepository
//    @MockK private lateinit var scanDirectoryUseCase: ScanDirectoryUseCase
//    private lateinit var scanDirectoryUseCase:
//    @MockK private lateinit var computeHashUseCase: ComputeHashUseCase
//    @MockK private lateinit var determineMediaTypeUseCase: DetermineMediaTypeUseCase
//    @MockK private lateinit var savePhotoUseCase : SavePhotoUseCase
//    @MockK private lateinit var getDataUseCase: GetDataUseCase
//    @MockK private lateinit var listDupesUseCase: ListDupesUseCase
//    @MockK private lateinit var moveFileUseCase: MoveFileUseCase
//    @MockK private lateinit var storeUnknownFileRefUseCase: StoreUnknownFileRefUseCase
//    @MockK private lateinit var needToUpdateHashUseCase: NeedToUpdateHashUseCase
//    @MockK private lateinit var renewFileUseCase: RenewFileUseCase
//    @MockK private lateinit var batchUpdateSessionUseCase: BatchUpdateSessionUseCase
//
//    private val sessionId: SessionId = SessionId(UUID.randomUUID())
//    private lateinit var app: App
//    private lateinit var params: App.Params
//    private val hashId: HashId = HashId(UUID.randomUUID())
//    val googleId = GooglePhotoId(UUID.randomUUID())
//    val sourceId = SourcePhotoId(UUID.randomUUID())
//    private lateinit var SUT: Video
//
//
//    @BeforeEach
//    fun setup() {
//        MockKAnnotations.init(this)
//
//        SUT = Video(sessionId, repo, { emptySequence() }) {
//            IO { Either.right(Hash("")) }
//        }
//        params = App.Params(
//            SOURCE_PATH,
//            BACKUP_PATH,
//            scanDirectoryUseCase,
//            computeHashUseCase,
//            determineMediaTypeUseCase,
//            savePhotoUseCase,
//            getDataUseCase,
//            listDupesUseCase,
//            moveFileUseCase,
//            storeUnknownFileRefUseCase,
//            sessionId,
//            needToUpdateHashUseCase,
//            renewFileUseCase,
//            batchUpdateSessionUseCase
//        )
//        coEvery { scanDirectoryUseCase.invoke(any()) } returns IO { listOf(File(SOURCE_PATH)).asSequence() }
//        coEvery { computeHashUseCase.invoke(any(), any(), any(), any()) } returns IO { hashId }
//        coEvery { determineMediaTypeUseCase.invoke(any()) } returns Some(Media.IMAGE)
//        coEvery { getDataUseCase.invoke(any()) } returns IO { Either.Right(ByteArray(5)) }
//        coEvery { savePhotoUseCase.invoke(any<SourceFileEntity>()) } returns IO { sourceId }
//        coEvery { savePhotoUseCase.invoke(any<GoogleFileEntity>()) } returns IO { googleId }
//        coEvery { listDupesUseCase.invoke() } returns IO { emptyList<SourceFileEntity>() }
//        every { batchUpdateSessionUseCase.invoke(any(), any())} returns IO{0}
//
//        app = App(params)
//    }
//
//    @Test
//    @DisplayName("It scans provided source")
//    fun scansSource() {
//        app = App(params)
//        coEvery { scanDirectoryUseCase.invoke(any()) } returns IO { emptyList<File>().asSequence() }
//        app.execute().unsafeRunSync()
//        coVerify { scanDirectoryUseCase.invoke(SOURCE_PATH) }
//    }
//
//    @Test
//    @DisplayName("It scans provided backup path")
//    fun scansBackup() {
//        logger.error { "TEST" }
//        app = App(params)
//        coEvery { scanDirectoryUseCase.invoke(any()) } returns IO { emptyList<File>().asSequence() }
//        app.execute().unsafeRunSync()
//        coVerify { scanDirectoryUseCase.invoke(BACKUP_PATH) }
//    }
//
//    @Test
//    @DisplayName("It gets the media type of files found")
//    fun getsMediaType() {
//        app = App(params)
//        every { needToUpdateHashUseCase.invoke(any(), any())} returns IO{false}
//        every { renewFileUseCase.invoke(any(), any()) } returns IO{}
//
//        app.execute().unsafeRunSync()
//        coVerify { determineMediaTypeUseCase.invoke(File(SOURCE_PATH)) }
//    }
//
//    @Test
//    @DisplayName("If do not need to update hash, does not compute hash")
//    fun doesNotComputeHash() {
//        every { scanDirectoryUseCase.invoke(any()) } returns IO{listOf(File("")).asSequence()}
//        every { determineMediaTypeUseCase.invoke(any()) } returns Some(Media.IMAGE)
//        every { needToUpdateHashUseCase.invoke(any(), source) } returns IO{false}
//        every { needToUpdateHashUseCase.invoke(any(), backup) } returns IO{false}
//        every { renewFileUseCase.invoke(any(), any()) } returns IO{Unit}
//
//        app.execute().unsafeRunSync()
//
//        coVerify(exactly=0) { computeHashUseCase.invoke(any(), any(), any(), source) }
//    }
//
//    @Test
//    @DisplayName("It computes hashes for files found if they need to update the hash and if it could read the file")
//    fun computesHash() {
//        val data = ByteArray(5)
//        every { scanDirectoryUseCase.invoke(any()) } returns IO{listOf(File(SOURCE_PATH)).asSequence()}
//        every { determineMediaTypeUseCase.invoke(any()) } returns Some(Media.IMAGE)
//        every { needToUpdateHashUseCase.invoke(any(), any()) } returns IO{true}
//        every { getDataUseCase.invoke(GetDataUseCase.Params(File(""), Media.IMAGE))} returns IO.just(Either.right(data))
//        every { computeHashUseCase.invoke(any(), any(), any(), any()) } returns IO{hashId}
//        every { savePhotoUseCase.invoke(any()) } returns IO{SourcePhotoId(UUID.randomUUID())}
//
//        app.execute().unsafeRunSync()
//
//        verify { computeHashUseCase.invoke(data, SOURCE_PATH, 0, source) }
//    }
//
//    @Test
//    @DisplayName("It inserts a source entity for an image it's found")
//    fun insertsFoundEntity() {
//        val slot = slot<FileEntity>()
//        every { needToUpdateHashUseCase.invoke(any(), any())} returns IO{true}
//
//        app.execute().unsafeRunSync()
//
//        coVerify { savePhotoUseCase.invoke(capture(slot)) }
//        assertEquals(Some(hashId), slot.captured.hash)
//        assertTrue(SOURCE_PATH in slot.captured.absolutePath)
//    }
//
//    @Test
//    @DisplayName("It moves file it's found")
//    fun movesFile() {
//        val sourceFileEntity = SourceFileEntity(
//            "",
//            Some(hashId),
//            0,
//            0,
//            SessionId(UUID.randomUUID()),
//            Media.IMAGE
//        )
//        coEvery { listDupesUseCase.invoke() } returns IO { listOf(sourceFileEntity) }
//        coEvery { moveFileUseCase.invoke(any()) } returns IO { Either.Right(File("").toPath()) }
//        every { needToUpdateHashUseCase.invoke(any(), any()) } returns IO { false }
//        every { renewFileUseCase.invoke(any(), any() )} returns IO{}
//
//        app.execute().unsafeRunSync()
//
//        coVerify { moveFileUseCase.invoke(sourceFileEntity) }
//    }
//
//    @Test
//    @DisplayName("When a file is not an image or video, stores in table")
//    fun storesUnknown() {
//        coEvery { determineMediaTypeUseCase(any()) } returns None
//        coEvery { storeUnknownFileRefUseCase(any()) } returns IO { Either.Right(UUID.randomUUID())}
//        val slot = slot<File>()
//
//        app.execute().unsafeRunSync()
//
//        coVerify { storeUnknownFileRefUseCase(capture(slot)) }
//        assertEquals(File(SOURCE_PATH), slot.captured)
//    }
//
//    @Test
//    @DisplayName("When only one param invoked, scan it and exit")
//    fun oneParamBehavior() {
//        val result = argsParser(arrayOf("foo"))
//        assertEquals(result, Either.Right(PathArgs(Some(File("foo")), None, None)))
//    }
//
//    @Test
//    @DisplayName("params parser returns a two-param arg with Some source and Some backup and Some pwd as destination")
//    fun twoParamBehavior() {
//        val result = argsParser(arrayOf("foo", "bar"))
//        assertEquals(result, Either.Right(PathArgs(
//            Some(File("foo")),
//            Some(File("bar")),
//            Some(File(""))
//        )))
//    }
//
//    @Test
//    @DisplayName("params parser returns three-param arg with Some for all three")
//    fun threeParamBehavior() {
//        val result = argsParser(arrayOf("foo", "bar", "baz"))
//        assertEquals(result, Either.Right(PathArgs(
//            Some(File("foo")),
//            Some(File("bar")),
//            Some(File("baz"))
//        )))
//    }
//
//    @Test
//    @DisplayName("params parser returns Left NoPaths exception when args is empty")
//    fun noParamBehavior() {
//        val result = argsParser(emptyArray<String>())
//        assertEquals(result, Either.Left(ArgumentsException.NoPaths))
//    }
//
//    @Test
//    @DisplayName("params parser returns Left Too Many exception when args is more than 3")
//    fun tooManyParamBehavior() {
//        val result = argsParser(arrayOf("", "", "", ""))
//        assertEquals(result, Either.Left(ArgumentsException.TooManyPaths))
//    }
//
//    @Test
//    @DisplayName("videoScan filters anything not with mp4, mpg, mpeg, avi extension")
//    fun filterNonVideo() {
//        val walker = { _:File -> listOf("foo.bar", "foo.avi", "foo.mpg", "foo.xyz", "foo.mpeg", "foo.xmas", "foo.avi").map { File(it) }.asSequence() }
//
//        val seq: Sequence<File> = SUT.copy(walker=walker).videoScan("").unsafeRunSync()
//
//        assertEquals(4, seq.toList().size)
//        assertTrue(File("foo.avi") in seq)
//        assertTrue(File("foo.mpg") in seq)
//        assertTrue(File("foo.mpeg") in seq)
//        assertTrue(File("foo.avi") in seq)
//        assertFalse(File("foo.bar") in seq)
//    }
//
//    @Test
//    @DisplayName("storeSourceVideo upserts correct entity and returns the upserted ID")
//    fun createCorrectEntity() {
//        val file = File("")
//        val slot = slot<SourceFileEntity>()
//        val id = SourcePhotoId(UUID.randomUUID())
//        coEvery { repo.upsertFile(any()) } returns id
//
//        val result = SUT.storeSourceVideo(file).unsafeRunSync()
//
//        coVerify { repo.upsertFile(capture(slot)) }
//        assertEquals(id, result)
//        assertEquals(file.canonicalPath, slot.captured.absolutePath)
//        assertEquals(None, slot.captured.hash)
//        assertEquals(sessionId, slot.captured.sessionId)
//        assertEquals(Media.VIDEO, slot.captured.type)
//    }
//
//    @Test
//    @DisplayName("storeSourceVideo updates entity that does exist (new session)")
//    fun storeUpdatesEntity() {
//        val file = File("")
//        coEvery { repo.upsertFile(any())} returns SourcePhotoId(UUID.randomUUID())
//        val slot = slot<SourceFileEntity>()
//
//        SUT.storeSourceVideo(file).unsafeRunSync()
//
//        coVerify { repo.upsertFile(capture(slot)) }
//        assertEquals(sessionId, slot.captured.sessionId)
//    }
//
//    @Test
//    @DisplayName("shouldStoreBackupVideo returns true if there are source files with same size in DB")
//    fun shouldStore() {
//        coEvery { repo.findSourceByFileSize(any(), SessionId(any())) } returns listOf(EntityFactory.build(source, File(""), None, Media.VIDEO) as SourceFileEntity)
//        coEvery { repo.upsertFile(any()) } returns SourcePhotoId(UUID.randomUUID())
//        coEvery { repo.upsertHash(any()) } returns HashId(UUID.randomUUID())
//
//        val result = SUT.shouldStoreBackupVideo(File("")).unsafeRunSync()
//
//        assertTrue(result)
//    }
//
//    @Test
//    @DisplayName("shouldStoreBackupVideo returns false if no source files with same size in DB")
//    fun shouldNotStore() {
//        coEvery { repo.findSourceByFileSize(any(), SessionId(any())) } returns emptyList()
//
//        val result = SUT.shouldStoreBackupVideo(File("")).unsafeRunSync()
//
//        assertFalse(result)
//    }
//
//    @Test
//    @DisplayName("storeBackupVideo upserts hash")
//    fun insertsHash() {
//        val file = File("")
//        val slot = slot<HashEntity>()
//        coEvery { repo.upsertHash(any()) } returns HashId(UUID.randomUUID())
//        coEvery { repo.upsertFile(any()) } returns GooglePhotoId(UUID.randomUUID())
//
//        SUT.storeBackupVideo(file).unsafeRunSync()
//
//        coVerify { repo.upsertHash(capture(slot)) }
//        assertEquals(sessionId, slot.captured.sessionId)
//        assertEquals(Hash(""), slot.captured.hash)
//    }
//
////    @Test
////    @DisplayName("storeBackupVideo finds a hash, renews the hash")
////    fun renewHash() {
////        val file = File("")
////        coEvery { repo.getHashId(Hash(any()))} returns Some(hashId)
////        coEvery { repo.renewHash(hashId, sessionId)} just runs
////
////        coEvery { repo.upsertFile(any())} returns GooglePhotoId(UUID.randomUUID())
////
////        SUT.storeBackupVideo(file).unsafeRunSync()
////
////        coVerify { repo.renewHash(hashId, sessionId) }
////    }
//
////    @Test
////    @DisplayName("storeBackupVideo backs up new entity, including generated HashId in entity")
////    fun backsUpEntity() {
////        val file = File("")
////        val slot = slot<GoogleFileEntity>()
////        coEvery { repo.backedUp(any()) } returns None
////        coEvery { repo.getHashId(Hash(any()))} returns Some(hashId)
////        coEvery { repo.renewHash(HashId(any()), SessionId(any()))} just runs
////        coEvery { repo.backUp(any()) } returns GooglePhotoId(UUID.randomUUID())
////
////        SUT.storeBackupVideo(file).unsafeRunSync()
////
////        coVerify { repo.backUp(capture(slot)) }
////        assertEquals(sessionId, slot.captured.sessionId)
////        assertEquals(Some(hashId), slot.captured.hash)
////    }
//
//    @Test
//    @DisplayName("runVideoPortion will receive a scan of source video files and store them")
//    fun runVideoPortionSourceScanAndStore() {
//        val videoScan: (String) -> IO<Sequence<File>> = {IO { listOf(File("foo"), File("bar"), File("baz")).asSequence() } }
//        val spy = spyk(SUT)
//        every { spy.storeSourceVideo(any()) } returns IO { SourcePhotoId(UUID.randomUUID())}
//
//        SUT.runVideoPortion(
//            "",
//            "",
//            videoScan = videoScan,
//            storeSource={ spy.storeSourceVideo(it) }).unsafeRunSync()
//
//        verify { spy.storeSourceVideo(File("foo")) }
//    }
//
//    @Test
//    @DisplayName("runVideoPortion will receive a scan of backup video files and query whether each should be stored")
//    fun runVideoPortionBackupScan() {
//        val spy = spyk(SUT)
//        every { spy.videoScan(any()) } returns IO { listOf(File("foo"), File("bar")).asSequence() }
//        every { spy.storeSourceVideo(any()) } returns IO { SourcePhotoId(UUID.randomUUID())}
//        every { spy.storeBackupVideo(any())} returns IO { Right(GooglePhotoId(UUID.randomUUID()))}
//        every { spy.shouldStoreBackupVideo(any()) } returns IO { true }
//
//        spy
//            .runVideoPortion("", "").unsafeRunSync()
//            .toList()
//
//        verify { spy.shouldStoreBackupVideo(File("foo")) }
//        verify { spy.shouldStoreBackupVideo(File("bar")) }
//    }
//
//    @Test
//    @DisplayName("Walker logs directories")
//    fun walkerTest() {
//        walker(File("/Users/kylegoetz/Documents/workspace")).toList()
//    }
//
//    @Test
//    @DisplayName("it batch updates files that only need session ID updated")
//    fun batchUpdate() {
//        val fileList = listOf(
//            File("/path"),
//            File("/to"),
//            File("/thing")
//        )
//        every { scanDirectoryUseCase.invoke(any()) } returns IO { fileList.asSequence() }
//        every { determineMediaTypeUseCase.invoke(any()) } returns Some(Media.IMAGE)
//        every { needToUpdateHashUseCase.invoke(fileList[0], any()) } returns IO{false}
//        every { needToUpdateHashUseCase.invoke(fileList[1], any()) } returns IO{false}
//        every { needToUpdateHashUseCase.invoke(fileList[2], any()) } returns IO{true}
//        every { getDataUseCase.invoke(any()) } returns IO{ left(IllegalArgumentException("")) }
//        every { batchUpdateSessionUseCase.invoke(any(), any()) } returns IO{2}
//
//        app.execute().unsafeRunSync()
//
//        verify { batchUpdateSessionUseCase(source, listOf(fileList[0], fileList[1]))}
//    }
//}